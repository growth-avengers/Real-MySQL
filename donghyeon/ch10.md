# ch10. 실행계획

- 통계 정보
	- MySQL 5.7버전까지는 테이블과 인덱스에 대한 개괄적인 정보로 실행 계획 수립
	- MySQL 8.0버전부터는 히스토그램(인덱스되지 않은 컬럼들에 대한 데이터 분포도) 정보도 추가
	- 테이블 및 인덱스 통계 정보
		- 비용 기반 최적화에서 가장 중요한 정보
		- MySQL 5.5버전 까지는 각 테이블의 통계정보가 메모리에만 관리되어 서버 재시작시 사라짐
		- 5.6버전부터는 각 테이블의 통계 정보를 `mysql` 데이터베이스의 `innodb_index_stats` 테이블과 `innodb_table_stats` 테이블로 영구적으로 관리 가능
			- 테이블 생성시 `STATS_PERSISTENT` 옵션으로 테이블 단위로 영구적인 통계정보를 보관할 지 결정
		- 테이블의 통계 정보가 자주 갱신되면 원하지 않은 실행 계획으로 쿼리를 실행할 수 있음
			- `innodb_stats_auto_recalc` 옵션으로 통계 정보 자동 갱신을 비활성화 할 수 있음
	- 히스토그램(Histogram)
		- MySQL 8.0버전부터 컬럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보 활용
		- 히스토그램 정보는 컬럼 단위로 관리되는데 `ANALYZE TABLE ... UPDATE HISTOGRAM` 명령으로 수동 수집 및 관리됨
		- 히스토그램 정보는 시스템 딕셔너리에 저장되고, MySQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 `information_schema` 데이터베이스의 `column_statistics` 테이블로 로드
		- 히스토그램의 종류
			- Singleton Histogram: 컬럼값 개별로 레코드 건수를 관리. Value-Based 히스토그램 또는 도수 분포라고 불림
			- Equi-Height Histogram: 컬럼값의 범위를 균등한 개수로 구분해 관리. Height-Balanced 히스토그램으로 불림
		- 히스토그램은 버킷(Bucket) 단위로 구분되어 레코드 건수(싱글톤)나 컬럼값의 범위(높이 균형)가 관리됨
	- 코스트 모델(Cost Model)
		- 전체 쿼리의 비용을 계산하는데 필요한 단위 작업들의 비용을 코스트 모델이라고 함
		- 작업의 종류
			- 디스크로부터 데이터 페이지 읽기
			- 메모리(InnoDB 버퍼 풀)로부터 데이터 페이지 읽기
			- 인덱스 키 비교
			- 레코드 평가
			- 메모리 임시 테이블 작업
			- 디크스 임시 테이블 작업
		- 작업 비용은 H/W마다 달라질 수 있기 때문에 고정된 비용을 적용하는 것은 실행 계획 수립의 방해 요소
		- MySQL 5.7버전부터 단위 작업의 비용을 DBMS 관리자가 조정할 수 있게 개선
		- MySQL 8.0의 코스트 모델은 `mysql` DB의 두 테이블에 저장되어 있는 설정값을 사용
			- `server_cost`: 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
			- `engine_cost`: 레코드를 가진 데이터 페이지를 가져오는 비용 관리
- 실행 계획 확인
	- MySQL 8.0 버전부터는 `FORMAT` 옵션으로 실행 계획 출력 포맷을 JSON, TREE, 단순 테이블 형태 중 선택할 수 있음
	- TREE 포맷의 실행 계획에서 실행 순서 확인하는 방법
		- 들여쓰기가 같은 레벨에서는 상단에 위치한 라인이 먼저 실행
		- 들여쓰기가 다른 레벨에서는 가장 안쪽에 위치한 라인이 먼저 실행
- 실행 계획 분석
	- id
	- select_type
		- SIMPLE: `UNION`이나 서브쿼리를 사용하지 않는 단순한 `SELECT` 쿼리
		- PRIMARY: `UNION`이나 서브쿼리를 가지는 쿼리의 실행계획의 가장 바깥쪽에 있는 단위 쿼리
		- UNION: `UNON`으로 결합하는 단위 쿼리 가운데 두 번째 이후의 단위 쿼리. 첫 번째 단위 쿼리는 `DERIVED` 타입으로 표시
		- DEPENDENT UNION: `UNION`이나 `UNION ALL`로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 경우
		- UNION RESULT: `UNION` 결과를 담아두는 테이블. MySQL 8.0부터는 `UNION ALL`의 경우 임시 테이블을 사용하지 않도록 개선
		- SUBQUERY: `select_type`에서의 서브쿼리는 `FROM`절 외에 사용되는 서브쿼리만을 의미
			- Nested Query: `SELECT`절에 사용된 서브쿼리
			- Subquery: `WEHRE`절에 사용된 서브쿼리
			- Derived Table: `FROM`절에 사용된 서브쿼리 
			- Scalar Subqeury: 하나의 값만 반환하는 서브쿼리
			- Row Subquery: 하나의 레코드만 반환하는 서브쿼리
		- DEPENDENT SUBQUERY: 서브쿼리가 바깥쪽 쿼리에서 정의된 컬럼을 사용하는 경우
		- DERIVED: 단위 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블(파생 테이블)을 생성하는 경우
		- DEPENDENT DERIVED: 래터럴 조인(Lateral Join)을 사용한 경우
		- UNCACHEABLE SUBQUERY: 서브쿼리에 포함된 요소에 의해 캐시가 불가능한 경우
			- 사용자 변수가 서브쿼리에 사용된 경우
			- NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리 내에 사용된 경우
			- `UUID()`나 `RAND()`와 같이 결과값이 호출할 때 마다 달라지는 함수가 서브쿼리에 사용된 경우
		- UNCACHEABLE UNION: `UNION` 속성과 `UNCACHEABLE` 속성의 혼합
		- MATERIALIZED: `FROM`절이나 `IN(subquery)` 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용. MySQL 5.6버전부터 도입
	- table
		- NULL: FROM 절이 없거나 `FROM DUAL`(DUAL 예약어)를 사용
		- `<>`: 임시 테이블
	- partitions
		- 조회하려는 데이터가 저장된 파티션 위치
		- 파티션 프루닝(Partition pruning): 파티션이 여러 개인 테이블에서 불필요한 파티션을 빼는 과정